"use strict";(self.webpackChunkbabylonjs_ocean_demo=self.webpackChunkbabylonjs_ocean_demo||[]).push([[39,220],{3710:(e,t,i)=>{i.r(t),i.d(t,{FFT:()=>s});var n=i(4684),r=i(7991);class s{constructor(e,t,i,s,a){this._engine=e,this._rttDebug=i,this._debugFirstIndex=s,this._size=a,this._horizontalStepIFFT=[],this._verticalStepIFFT=[],this._permute=null;const u=new n.ComputeShader("computeTwiddleFactors",this._engine,{computeSource:"const PI: f32 = 3.1415926;\n\n@group(0) @binding(0) var PrecomputeBuffer : texture_storage_2d<rgba32float, write>;\n\nstruct Params {\n    Step : i32,\n    Size : i32,\n};\n\n@group(0) @binding(1) var<uniform> params : Params;\n\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\n{\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\n}\n\nfn complexExp(a: vec2<f32>) -> vec2<f32>\n{\n\treturn vec2<f32>(cos(a.y), sin(a.y)) * exp(a.x);\n}\n\n@compute @workgroup_size(1,8,1)\nfn precomputeTwiddleFactorsAndInputIndices(@builtin(global_invocation_id) id : vec3<u32>)\n{\n    let iid = vec3<i32>(id);\n\tlet b = params.Size >> (id.x + 1u);\n\tlet mult = 2.0 * PI * vec2<f32>(0.0, -1.0) / f32(params.Size);\n\tlet i = (2 * b * (iid.y / b) + (iid.y % b)) % params.Size;\n\tlet twiddle = complexExp(mult * vec2<f32>(f32((iid.y / b) * b)));\n\t\n    textureStore(PrecomputeBuffer, iid.xy, vec4<f32>(twiddle.x, twiddle.y, f32(i), f32(i + b)));\n\ttextureStore(PrecomputeBuffer, vec2<i32>(iid.x, iid.y + params.Size / 2), vec4<f32>(-twiddle.x, -twiddle.y, f32(i), f32(i + b)));\n}\n"},{bindingsMapping:{PrecomputeBuffer:{group:0,binding:0},params:{group:0,binding:1}},entryPoint:"precomputeTwiddleFactorsAndInputIndices"}),p=0|Math.log2(a);this._precomputedData=r.ComputeHelper.CreateStorageTexture("precomputeTwiddle",this._engine,p,this._size,n.Constants.TEXTUREFORMAT_RGBA),this._rttDebug.setTexture(this._debugFirstIndex,"precomputeTwiddle",this._precomputedData),this._params=new n.UniformBuffer(this._engine),this._params.addUniform("Step",1),this._params.addUniform("Size",1),u.setStorageTexture("PrecomputeBuffer",this._precomputedData),u.setUniformBuffer("params",this._params),this._params.updateInt("Size",this._size),this._params.update(),r.ComputeHelper.Dispatch(u,p,a/2,1),this._createComputeShaders()}IFFT2D(e,t){const i=0|Math.log2(this._size);let n=!1;for(let s=0;s<i;++s)n=!n,this._params.updateInt("Step",s),this._params.update(),this._horizontalStepIFFT[0].setTexture("InputBuffer",n?e:t,!1),this._horizontalStepIFFT[0].setStorageTexture("OutputBuffer",n?t:e),r.ComputeHelper.Dispatch(this._horizontalStepIFFT[0],this._size,this._size,1);for(let s=0;s<i;++s)n=!n,this._params.updateInt("Step",s),this._params.update(),this._verticalStepIFFT[0].setTexture("InputBuffer",n?e:t,!1),this._verticalStepIFFT[0].setStorageTexture("OutputBuffer",n?t:e),r.ComputeHelper.Dispatch(this._verticalStepIFFT[0],this._size,this._size,1);n&&r.ComputeHelper.CopyTexture(t,e,this._engine),this._permute.setTexture("InputBuffer",e,!1),this._permute.setStorageTexture("OutputBuffer",t),r.ComputeHelper.Dispatch(this._permute,this._size,this._size,1),r.ComputeHelper.CopyTexture(t,e,this._engine)}dispose(){this._precomputedData.dispose(),this._params.dispose()}_createComputeShaders(){for(let e=0;e<2;++e)this._horizontalStepIFFT[e]=new n.ComputeShader("horizontalStepIFFT",this._engine,{computeSource:"struct Params {\n    Step : i32,\n    Size : i32,\n};\n\n@group(0) @binding(1) var<uniform> params : Params;\n\n@group(0) @binding(3) var PrecomputedData : texture_2d<f32>;\n\n@group(0) @binding(5) var InputBuffer : texture_2d<f32>;\n@group(0) @binding(6) var OutputBuffer : texture_storage_2d<rg32float, write>;\n\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\n{\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\n}\n\n@compute @workgroup_size(8,8,1)\nfn horizontalStepInverseFFT(@builtin(global_invocation_id) id : vec3<u32>)\n{\n    let iid = vec3<i32>(id);\n    let data = textureLoad(PrecomputedData, vec2<i32>(params.Step, iid.x), 0);\n\tlet inputsIndices = vec2<i32>(data.ba);\n\n    let input0 = textureLoad(InputBuffer, vec2<i32>(inputsIndices.x, iid.y), 0);\n    let input1 = textureLoad(InputBuffer, vec2<i32>(inputsIndices.y, iid.y), 0);\n\n    textureStore(OutputBuffer, iid.xy, vec4<f32>(\n        input0.xy + complexMult(vec2<f32>(data.r, -data.g), input1.xy), 0., 0.\n    ));\n}\n"},{bindingsMapping:{params:{group:0,binding:1},PrecomputedData:{group:0,binding:3},InputBuffer:{group:0,binding:5},OutputBuffer:{group:0,binding:6}},entryPoint:"horizontalStepInverseFFT"}),this._horizontalStepIFFT[e].setUniformBuffer("params",this._params),this._horizontalStepIFFT[e].setTexture("PrecomputedData",this._precomputedData,!1),this._verticalStepIFFT[e]=new n.ComputeShader("verticalStepIFFT",this._engine,{computeSource:"struct Params {\n    Step : i32,\n    Size : i32,\n};\n\n@group(0) @binding(1) var<uniform> params : Params;\n\n@group(0) @binding(3) var PrecomputedData : texture_2d<f32>;\n\n@group(0) @binding(5) var InputBuffer : texture_2d<f32>;\n@group(0) @binding(6) var OutputBuffer : texture_storage_2d<rg32float, write>;\n\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\n{\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\n}\n\n@compute @workgroup_size(8,8,1)\nfn verticalStepInverseFFT(@builtin(global_invocation_id) id : vec3<u32>)\n{\n    let iid = vec3<i32>(id);\n    let data = textureLoad(PrecomputedData, vec2<i32>(params.Step, iid.y), 0);\n\tlet inputsIndices = vec2<i32>(data.ba);\n\n    let input0 = textureLoad(InputBuffer, vec2<i32>(iid.x, inputsIndices.x), 0);\n    let input1 = textureLoad(InputBuffer, vec2<i32>(iid.x, inputsIndices.y), 0);\n\n    textureStore(OutputBuffer, iid.xy, vec4<f32>(\n        input0.xy + complexMult(vec2<f32>(data.r, -data.g), input1.xy), 0., 0.\n    ));\n}\n"},{bindingsMapping:{params:{group:0,binding:1},PrecomputedData:{group:0,binding:3},InputBuffer:{group:0,binding:5},OutputBuffer:{group:0,binding:6}},entryPoint:"verticalStepInverseFFT"}),this._verticalStepIFFT[e].setUniformBuffer("params",this._params),this._verticalStepIFFT[e].setTexture("PrecomputedData",this._precomputedData,!1);this._permute=new n.ComputeShader("permute",this._engine,{computeSource:"@group(0) @binding(5) var InputBuffer : texture_2d<f32>;\n@group(0) @binding(6) var OutputBuffer : texture_storage_2d<rg32float, write>;\n\n@compute @workgroup_size(8,8,1)\nfn permute(@builtin(global_invocation_id) id : vec3<u32>)\n{\n    let iid = vec3<i32>(id);\n    let input = textureLoad(InputBuffer, iid.xy, 0);\n\n    textureStore(OutputBuffer, iid.xy, input * (1.0 - 2.0 * f32((iid.x + iid.y) % 2)));\n}\n"},{bindingsMapping:{InputBuffer:{group:0,binding:5},OutputBuffer:{group:0,binding:6}},entryPoint:"permute"})}}},8220:(e,t,i)=>{i.r(t),i.d(t,{WavesCascade:()=>a});var n=i(4684),r=i(8249),s=i(7991);class a{get displacement(){return this._displacement}get derivatives(){return this._derivatives}get turbulence(){return this._pingPongTurbulence?this._turbulence2:this._turbulence}constructor(e,t,i,a,u,p){this._engine=p,this._size=e,this._fft=i,this._lambda=0,this._pingPongTurbulence=!1,this._initialSpectrum=new r.InitialSpectrum(p,a,u,e,t),this._timeDependentSpectrum=new n.ComputeShader("timeDependentSpectrumCS",this._engine,{computeSource:"@group(0) @binding(1) var H0 : texture_2d<f32>;\n@group(0) @binding(3) var WavesData : texture_2d<f32>;\n\nstruct Params {\n    Time : f32,\n};\n\n@group(0) @binding(4) var<uniform> params : Params;\n\n@group(0) @binding(5) var DxDz : texture_storage_2d<rg32float, write>;\n@group(0) @binding(6) var DyDxz : texture_storage_2d<rg32float, write>;\n@group(0) @binding(7) var DyxDyz : texture_storage_2d<rg32float, write>;\n@group(0) @binding(8) var DxxDzz : texture_storage_2d<rg32float, write>;\n\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\n{\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\n}\n\n@compute @workgroup_size(8,8,1)\nfn calculateAmplitudes(@builtin(global_invocation_id) id : vec3<u32>)\n{\n    let iid = vec3<i32>(id);\n\tlet wave = textureLoad(WavesData, iid.xy, 0);\n\tlet phase = wave.w * params.Time;\n\tlet exponent = vec2<f32>(cos(phase), sin(phase));\n    let h0 = textureLoad(H0, iid.xy, 0);\n\tlet h = complexMult(h0.xy, exponent) + complexMult(h0.zw, vec2<f32>(exponent.x, -exponent.y));\n\tlet ih = vec2<f32>(-h.y, h.x);\n\n\tlet displacementX = ih * wave.x * wave.y;\n\tlet displacementY = h;\n\tlet displacementZ = ih * wave.z * wave.y;\n\n\tlet displacementX_dx = -h * wave.x * wave.x * wave.y;\n\tlet displacementY_dx = ih * wave.x;\n\tlet displacementZ_dx = -h * wave.x * wave.z * wave.y;\n\t\t \n\tlet displacementY_dz = ih * wave.z;\n\tlet displacementZ_dz = -h * wave.z * wave.z * wave.y;\n\n\ttextureStore(DxDz,   iid.xy, vec4<f32>(displacementX.x - displacementZ.y, displacementX.y + displacementZ.x, 0., 0.));\n\ttextureStore(DyDxz,  iid.xy, vec4<f32>(displacementY.x - displacementZ_dx.y, displacementY.y + displacementZ_dx.x, 0., 0.));\n\ttextureStore(DyxDyz, iid.xy, vec4<f32>(displacementY_dx.x - displacementY_dz.y, displacementY_dx.y + displacementY_dz.x, 0., 0.));\n\ttextureStore(DxxDzz, iid.xy, vec4<f32>(displacementX_dx.x - displacementZ_dz.y, displacementX_dx.y + displacementZ_dz.x, 0., 0.));\n}\n"},{bindingsMapping:{H0:{group:0,binding:1},WavesData:{group:0,binding:3},params:{group:0,binding:4},DxDz:{group:0,binding:5},DyDxz:{group:0,binding:6},DyxDyz:{group:0,binding:7},DxxDzz:{group:0,binding:8}},entryPoint:"calculateAmplitudes"}),this._buffer=s.ComputeHelper.CreateStorageTexture("buffer",this._engine,this._size,this._size,n.Constants.TEXTUREFORMAT_RG),this._DxDz=s.ComputeHelper.CreateStorageTexture("DxDz",this._engine,this._size,this._size,n.Constants.TEXTUREFORMAT_RG),this._DyDxz=s.ComputeHelper.CreateStorageTexture("DyDxz",this._engine,this._size,this._size,n.Constants.TEXTUREFORMAT_RG),this._DyxDyz=s.ComputeHelper.CreateStorageTexture("DyxDyz",this._engine,this._size,this._size,n.Constants.TEXTUREFORMAT_RG),this._DxxDzz=s.ComputeHelper.CreateStorageTexture("DxxDzz",this._engine,this._size,this._size,n.Constants.TEXTUREFORMAT_RG),this._timeDependentSpectrumParams=new n.UniformBuffer(this._engine),this._timeDependentSpectrumParams.addUniform("Time",1),this._timeDependentSpectrum.setTexture("H0",this._initialSpectrum.initialSpectrum,!1),this._timeDependentSpectrum.setTexture("WavesData",this._initialSpectrum.wavesData,!1),this._timeDependentSpectrum.setUniformBuffer("params",this._timeDependentSpectrumParams),this._timeDependentSpectrum.setStorageTexture("DxDz",this._DxDz),this._timeDependentSpectrum.setStorageTexture("DyDxz",this._DyDxz),this._timeDependentSpectrum.setStorageTexture("DyxDyz",this._DyxDyz),this._timeDependentSpectrum.setStorageTexture("DxxDzz",this._DxxDzz),a.setTexture(u+3,"DxDz",this._DxDz,2),a.setTexture(u+4,"DyDxz",this._DyDxz,2),a.setTexture(u+5,"DyxDyz",this._DyxDyz,2),a.setTexture(u+6,"DxxDzz",this._DxxDzz,2),this._texturesMerger=new n.ComputeShader("texturesMerger",this._engine,{computeSource:"struct Params {\n    Lambda : f32,\n    DeltaTime : f32,\n};\n\n@group(0) @binding(0) var<uniform> params : Params;\n\n@group(0) @binding(1) var Displacement : texture_storage_2d<rgba16float, write>;\n@group(0) @binding(2) var Derivatives : texture_storage_2d<rgba16float, write>;\n@group(0) @binding(3) var TurbulenceRead : texture_2d<f32>;\n@group(0) @binding(4) var TurbulenceWrite : texture_storage_2d<rgba16float, write>;\n\n@group(0) @binding(5) var Dx_Dz : texture_2d<f32>;\n@group(0) @binding(6) var Dy_Dxz : texture_2d<f32>;\n@group(0) @binding(7) var Dyx_Dyz : texture_2d<f32>;\n@group(0) @binding(8) var Dxx_Dzz : texture_2d<f32>;\n\n@compute @workgroup_size(8,8,1)\nfn fillResultTextures(@builtin(global_invocation_id) id : vec3<u32>)\n{\n    let iid = vec3<i32>(id);\n\n\tlet DxDz = textureLoad(Dx_Dz, iid.xy, 0);\n\tlet DyDxz = textureLoad(Dy_Dxz, iid.xy, 0);\n\tlet DyxDyz = textureLoad(Dyx_Dyz, iid.xy, 0);\n\tlet DxxDzz = textureLoad(Dxx_Dzz, iid.xy, 0);\n\t\n\ttextureStore(Displacement, iid.xy, vec4<f32>(params.Lambda * DxDz.x, DyDxz.x, params.Lambda * DxDz.y, 0.));\n\ttextureStore(Derivatives, iid.xy, vec4<f32>(DyxDyz.x, DyxDyz.y, DxxDzz.x * params.Lambda, DxxDzz.y * params.Lambda));\n\n\tlet jacobian = (1.0 + params.Lambda * DxxDzz.x) * (1.0 + params.Lambda * DxxDzz.y) - params.Lambda * params.Lambda * DyDxz.y * DyDxz.y;\n\n    var turbulence = textureLoad(TurbulenceRead, iid.xy, 0).r + params.DeltaTime * 0.5 / max(jacobian, 0.5);\n    turbulence = min(jacobian, turbulence);\n\n    textureStore(TurbulenceWrite, iid.xy, vec4<f32>(turbulence, turbulence, turbulence, 1.));\n}\n"},{bindingsMapping:{params:{group:0,binding:0},Displacement:{group:0,binding:1},Derivatives:{group:0,binding:2},TurbulenceRead:{group:0,binding:3},TurbulenceWrite:{group:0,binding:4},DxDz:{group:0,binding:5},DyDxz:{group:0,binding:6},DyxDyz:{group:0,binding:7},DxxDzz:{group:0,binding:8}},entryPoint:"fillResultTextures"}),this._displacement=s.ComputeHelper.CreateStorageTexture("displacement",this._engine,this._size,this._size,n.Constants.TEXTUREFORMAT_RGBA,n.Constants.TEXTURETYPE_HALF_FLOAT,n.Constants.TEXTURE_BILINEAR_SAMPLINGMODE),this._derivatives=s.ComputeHelper.CreateStorageTexture("derivatives",this._engine,this._size,this._size,n.Constants.TEXTUREFORMAT_RGBA,n.Constants.TEXTURETYPE_HALF_FLOAT,n.Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,!0),this._turbulence=s.ComputeHelper.CreateStorageTexture("turbulence",this._engine,this._size,this._size,n.Constants.TEXTUREFORMAT_RGBA,n.Constants.TEXTURETYPE_HALF_FLOAT,n.Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,!0),this._turbulence2=s.ComputeHelper.CreateStorageTexture("turbulence",this._engine,this._size,this._size,n.Constants.TEXTUREFORMAT_RGBA,n.Constants.TEXTURETYPE_HALF_FLOAT,n.Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,!0),this._texturesMergerParams=new n.UniformBuffer(this._engine),this._texturesMergerParams.addUniform("Lambda",1),this._texturesMergerParams.addUniform("DeltaTime",1),this._texturesMerger.setUniformBuffer("params",this._texturesMergerParams),this._texturesMerger.setStorageTexture("Displacement",this._displacement),this._texturesMerger.setStorageTexture("Derivatives",this._derivatives),this._texturesMerger.setTexture("DxDz",this._DxDz,!1),this._texturesMerger.setTexture("DyDxz",this._DyDxz,!1),this._texturesMerger.setTexture("DyxDyz",this._DyxDyz,!1),this._texturesMerger.setTexture("DxxDzz",this._DxxDzz,!1),a.setTexture(u+7,"displacement",this._displacement,2),a.setTexture(u+8,"derivatives",this._derivatives,2),a.setTexture(u+9,"turbulence",this._turbulence,1)}calculateInitials(e,t,i,n){this._lambda=e.lambda,this._initialSpectrum.generate(e,t,i,n)}calculateWavesAtTime(e){this._timeDependentSpectrumParams.updateFloat("Time",e),this._timeDependentSpectrumParams.update(),s.ComputeHelper.Dispatch(this._timeDependentSpectrum,this._size,this._size,1),this._fft.IFFT2D(this._DxDz,this._buffer),this._fft.IFFT2D(this._DyDxz,this._buffer),this._fft.IFFT2D(this._DyxDyz,this._buffer),this._fft.IFFT2D(this._DxxDzz,this._buffer);let t=this._engine.getDeltaTime()/1e3;t>.5&&(t=.5),this._texturesMergerParams.updateFloat("Lambda",this._lambda),this._texturesMergerParams.updateFloat("DeltaTime",t),this._texturesMergerParams.update(),this._pingPongTurbulence=!this._pingPongTurbulence,this._texturesMerger.setTexture("TurbulenceRead",this._pingPongTurbulence?this._turbulence:this._turbulence2,!1),this._texturesMerger.setStorageTexture("TurbulenceWrite",this._pingPongTurbulence?this._turbulence2:this._turbulence),s.ComputeHelper.Dispatch(this._texturesMerger,this._size,this._size,1),this._engine.generateMipmaps(this._derivatives.getInternalTexture()),this._engine.generateMipmaps(this._pingPongTurbulence?this._turbulence2.getInternalTexture():this._turbulence.getInternalTexture())}dispose(){this._initialSpectrum.dispose(),this._timeDependentSpectrumParams.dispose(),this._buffer.dispose(),this._DxDz.dispose(),this._DyDxz.dispose(),this._DyxDyz.dispose(),this._DxxDzz.dispose(),this._texturesMergerParams.dispose()}}},6039:(e,t,i)=>{i.r(t),i.d(t,{WavesGenerator:()=>a});var n=i(4684),r=i(3710),s=i(8220);class a{getCascade(e){return this._cascades[e]}get waterHeightMap(){return this._displacementMap}get waterHeightMapScale(){return this.lengthScale[0]}constructor(e,t,i,n,a){this._engine=i.getEngine(),this._rttDebug=n,this._startTime=(new Date).getTime()/1e3,this._displacementMap=null,this._wavesSettings=t,this._fft=new r.FFT(i.getEngine(),i,this._rttDebug,1,e),this._noise=this._generateNoiseTexture(e,a),this._rttDebug.setTexture(0,"noise",this._noise),this.lengthScale=[250,17,5],this._cascades=[new s.WavesCascade(e,this._noise,this._fft,this._rttDebug,2,this._engine),new s.WavesCascade(e,this._noise,this._fft,this._rttDebug,12,this._engine),new s.WavesCascade(e,this._noise,this._fft,this._rttDebug,22,this._engine)],this.initializeCascades()}initializeCascades(){let e=1e-4;for(let t=0;t<this.lengthScale.length;++t){const i=t<this.lengthScale.length-1?2*Math.PI/this.lengthScale[t+1]*6:9999;this._cascades[t].calculateInitials(this._wavesSettings,this.lengthScale[t],e,i),e=i}}update(){const e=(new Date).getTime()/1e3-this._startTime;for(let t=0;t<this._cascades.length;++t)this._cascades[t].calculateWavesAtTime(e);this._getDisplacementMap()}dispose(){for(let e=0;e<this._cascades.length;++e)this._cascades[e].dispose();this._noise.dispose(),this._fft.dispose()}_getDisplacementMap(){var e;null===(e=this._cascades[0].displacement.readPixels(void 0,void 0,void 0,void 0,!0))||void 0===e||e.then((e=>{this._displacementMap=new Uint16Array(e.buffer)}))}_normalRandom(){return Math.cos(2*Math.PI*Math.random())*Math.sqrt(-2*Math.log(Math.random()))}_generateNoiseTexture(e,t){const i=t?4:2,r=new Float32Array(e*e*i);if(t){const e=new Uint8Array(t),i=new Uint8Array(4),n=new Float32Array(i.buffer,0,1);let s=2379,a=0;for(let t=0;t<256;++t){s+=8,s+=1024,s+=1024;for(let t=0;t<256;++t)i[0]=e[s++],i[1]=e[s++],i[2]=e[s++],i[3]=e[s++],r[a+1+4*t]=n[0];for(let t=0;t<256;++t)i[0]=e[s++],i[1]=e[s++],i[2]=e[s++],i[3]=e[s++],r[a+0+4*t]=n[0];for(let e=0;e<256;++e)r[a+3+4*e]=1;a+=1024}}else for(let t=0;t<e;++t)for(let i=0;i<e;++i)r[i*e*2+2*t+0]=this._normalRandom(),r[i*e*2+2*t+1]=this._normalRandom();const s=new n.RawTexture(r,e,e,2===i?n.Constants.TEXTUREFORMAT_RG:n.Constants.TEXTUREFORMAT_RGBA,this._engine,!1,!1,n.Constants.TEXTURE_NEAREST_SAMPLINGMODE,n.Constants.TEXTURETYPE_FLOAT);return s.name="noise",s}}}}]);
//# sourceMappingURL=39.3b57e4a3e5edda1a0cbe.js.map